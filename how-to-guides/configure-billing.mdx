---
title: "Configure Billing"
---

Design billing that matches AI usage and preserves your margins. You can change pricing and rules in the dashboard at any time without touching your app code. You can use **one** method or **combine** them.

### 1. Deposit credits via **Deposit API** _(Default mode only)_

**What it does:** Credit a user’s **app‑scoped** wallet with an arbitrary amount.

**Use cases**

- Integrate **any payment system** (PSP, crypto, app store) — after you confirm payment, deposit credits.
- Grant **trial credits** to new users or cohorts.
- Add credits at the **start of a billing cycle** or for **goodwill/refunds**.

**Notes**

- Appears as a **`deposit`** in the ledger (developer‑initiated).
- Works only in **Default mode** (virtual, app‑scoped balance).
- Pair with the automated **Stripe restricted key** setup for a zero‑code top‑up flow.

### 2. One‑off charges via **Charge API** _(Both modes)_

**What it does:** Create a **manual, one‑time charge** independent of token usage.

**Use cases**

- Bill for **tool usage** (e.g., MCP tool run, file conversion, image upscaling).
- Charge for **feature access** (e.g., unlock premium mode or export).
- Apply **post‑processing** fees (e.g., retrieval/storage, long‑running jobs).

**Notes**

- Appears as a **`charge`** in the ledger.
- If funds/authorization are missing, the API returns a **renderable message** (auth/top‑up link); show it as a normal assistant reply.
- Use an **Idempotency‑Key** to avoid duplicates; include **metadata** for reconciliation.

### 3. Automatic usage billing via the **Proxy** _(Both modes)_

**What it does:** The proxy **meters tokens** and computes the charge from the **selected model price** + your **markup**. It writes the charge to the ledger and returns the model response (or an auth/top‑up message) — no custom billing code required.

**Setup**

- **Connect a provider**: BYOK (Default required; Shared optional) or the **built‑in provider** (Shared).
- **Set per‑model prices** and an optional **markup %** in the dashboard.

**Behavior**

- Charge = _usage (prompt + completion tokens) × model price_ **±** _markup_.
- Per‑model pricing lets users pick price/performance while you keep margins predictable.
- Changes take effect **without code changes**.

### 4. Per‑request & hybrid pricing _(Coming soon)_

Configure fixed **per‑request** fees, or **hybrid** pricing: _minimum fee per request + per‑token usage_. Useful for short prompts, tools/actions, and stabilizing margins across mixed workloads.

---

### Recommendations & guardrails

- Prefer **per‑model dynamic pricing** and set a **minimum per‑request** fee to cover short prompts.
- Add **max tokens** and **spend caps** to prevent runaway costs.
- Keep pricing rules in the dashboard; don’t hardcode rates in your app.
- For UI display, read prices/models from the separate **API Reference (Models)**.
